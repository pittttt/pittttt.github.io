<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pittttt.github.io</id>
    <title>PITT&apos;S BLOG</title>
    <updated>2025-07-27T12:22:45.321Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pittttt.github.io"/>
    <link rel="self" href="https://pittttt.github.io/atom.xml"/>
    <subtitle>所见即所得</subtitle>
    <logo>https://pittttt.github.io/images/avatar.png</logo>
    <icon>https://pittttt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, PITT&apos;S BLOG</rights>
    <entry>
        <title type="html"><![CDATA[探究浮点数计算中的精度问题]]></title>
        <id>https://pittttt.github.io/post/tan-jiu-fu-dian-shu-ji-suan-zhong-de-jing-du-wen-ti/</id>
        <link href="https://pittttt.github.io/post/tan-jiu-fu-dian-shu-ji-suan-zhong-de-jing-du-wen-ti/">
        </link>
        <updated>2024-12-27T10:22:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一探究竟众所周知的 double 精度问题</p>
</blockquote>
<h2 id="问题再现">问题再现</h2>
<p>我们都知道浮点数计算有精度问题，这里还是踩坑了，简单描述下产品需求，我们需要通过一个公 式来计算出当前的用户进度，这个进度是有小数的，简化为下述代码</p>
<pre><code class="language-java">public static void main(String[] args) {
        double d = 0.1;
        for (int i = 1; i &amp;lt; 10; i++) {
            System.out.println(i * d);
} }
代码输出如下:
0.1
0.2 0.30000000000000004 0.4
0.5
0.6000000000000001
0.7000000000000001
0.8
0.9
</code></pre>
<p>上面代码的输出结果有两个问题:<br>
一是 double 运算的精度问题从何而来，double 又是如何运算的; 二是为什么只有部分结果有问题，有些结果看起来是“准确的”; 就是这部分看似“准确”的结果迷惑了我，下面我们带着这两个疑问来探究一下这个问题</p>
<h2 id="double-的二进制">double 的二进制</h2>
<p>我们都知道整数十进制转二进制是除 2 取余法，这里不再赘述，我们主要看看小数是如何存储的， 这里借用一张图来说明，简单来说，就是分别将整数部分和小数部分转换为二进制，小数部分采用 乘 2 取整的方法，最后将两部分结合在一起<br>
<img src="https://pittttt.github.io/post-images/1753612612427.png" alt="" loading="lazy"><br>
根据浮点数所采用的<a href="https://en.wikipedia.org/wiki/IEEE_754"> IEEE_754</a> 国际标准，1000.101 需要进行规格化，移动小数点后，这个数可以表 示为 1.000101 x 2^3，类似于科学计数法，并且规定小数点左边有且只有一位，必须为 1，同时规 定了单精度浮点数和双精度浮点数的存储格式，如下图所示:<br>
<img src="https://pittttt.github.io/post-images/1753612703957.png" alt="" loading="lazy"><br>
●符号位:表示正负数，0 代表正数，1 代表负数 ●指数位:表示小数点的偏移位置，指数位的长度越长则数值的表达范围就越大，double 的指数<br>
部分是 11 位，IEEE 标准规定双精度浮点的指数取值范围是 -1022~1023，为了不使指数出现负 数，就要加个偏移量， double 的指数偏移量是 1023<br>
●尾数位:小数点右侧的部分，尾数长度越长，则这个数字的精度越高<br>
通过上述规则，我们将 0.1 转换为二进制，会发现<br>
<img src="https://pittttt.github.io/post-images/1753612792431.png" alt="" loading="lazy"><br>
由于计算机的资源是有限的，所以其实没办法精确地表示 0.1，精度就取决于尾数能存放多少位， 就是在这里，精度损失了，下面我们看下一开始代码中的 0.1*3 是如何计算的</p>
<blockquote>
<p>通过 <a href="https://binaryconvert.com/result_double.html?decimal=048046049">binaryconvert</a>可以得到浮点数对应的二进制表示</p>
</blockquote>
<p><img src="https://pittttt.github.io/post-images/1753612894076.png" alt="" loading="lazy"><br>
得到的 1.001100110011001100110011001100110011001100110011001110 x 2^-2 其尾数已经超过了 52 位，这里 IEEE 采用就近舍入<a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">银行家算法</a>，<strong>这里再次造成精度误差</strong><br>
<img src="https://pittttt.github.io/post-images/1753613143935.png" alt="" loading="lazy"></p>
<p>这样我们就得到了通过二进制计算的浮点运算结果 1.0011001100110011001100110011001100110011001100110100x2^-2，将其转换为 10 进制，即为 0.30000000000000004(至于为什么是这个数字，下面会提到)，通过上面的运算，我们知道了浮点 运算的计算结果是不准确的，或者说浮点数本身的二进制存储结果就是不精确的，其实到这里，大 概可以猜到一开始 for 循环中的运算结果为什么部分是“准确”的了</p>
<h2 id="看似正确的结果">看似正确的结果</h2>
<p>为了解答第二个问题，我们需要知道浮点数的精度范围，IEEE 中规定了精度由尾数位来控制， double 类型的尾数有 52 位，因为规格化后首位必须为 1，所以一共有 53 位二进制，能够准确(不丢失精度)表示的十进制是 17 位，这里直接放出公式，具体的计算原理可参考 <a href="https://www.exploringbinary.com/number-of-decimal-digits-in-a-binary-integer/">Number of Decimal Digits In a Binary Integer</a><br>
ceil(1+N*log10(2)) N为二进制位数<br>
知道了这个我们再回头看双精度类型的 0.1 的二进制是如何表示的<br>
<img src="https://pittttt.github.io/post-images/1753613413472.png" alt="" loading="lazy"><br>
二进制中的尾数位越多，则所表示的十进制数就越接近 0.1，但是理论上永远不会相等(类比有限小 数永远无法准确表示 1/3)，其实这个二进制转换成十进制后为 0.10000000000000000555111... (当然这里的精度已经超过双精度所能表示的范围了，不能够直接用 double 类型在 Java 程序中进 行验证)由于双精度浮点数的精度限制(17 位小数)，这个数字看似在部分浮点数的运算结果中是 “没问题”的，本质原因是双精度浮点数的精度范围“丢弃”了误差，其实是一种“障眼法”。<br>
后记<br>
其实要想避免这个问题并不难，如果对浮点数类型的计算结果有精准度的要求，比如涉及到钱，分 数之类的，直接使用 BigDecimal 处理最为稳妥</p>
<h2 id="read-more">Read More:</h2>
<p><a href="https://0.30000000000000004.com/">https://0.30000000000000004.com/</a><br>
<a href="https://babbage.cs.qc.cuny.edu/IEEE-754/">https://babbage.cs.qc.cuny.edu/IEEE-754/</a><br>
<a href="https://web.archive.org/web/20120208075518/http:/www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE Standard 754 for Binary Floating-Point Arithmetic</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从请求阻塞异常到 Lambda 实现原理]]></title>
        <id>https://pittttt.github.io/post/cong-qing-qiu-zu-sai-yi-chang-dao-lambda-shi-xian-yuan-li/</id>
        <link href="https://pittttt.github.io/post/cong-qing-qiu-zu-sai-yi-chang-dao-lambda-shi-xian-yuan-li/">
        </link>
        <updated>2024-03-27T11:24:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="情景再现">情景再现</h2>
<p>在 CNY 开发的时候，提供出去的 SDK 工具类中有一个 ReloadableCache，我想放在 static 代码块中 对它进行初始化。下面这段代码所产生的现象就是，一旦请求打到接口，程序就会阻塞，产生死锁</p>
<p>代码简化如下:</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/test&quot;, method = {GET, POST}) 
public String test() {
        //程序在这里阻塞，永远不会返回 
        return Utils.getCache();
}
public class Utils  {
        private static final ReloadableCache&lt;String&gt; RELOADABLE_CACHE =                      LocalCacheFactory.&lt;String&gt; newBuilder()
                .enableAutoReload(() -&gt; Duration.ofSeconds(Kconf.get())) 
                .factory(Utils::init)
                .name(&quot;reloadableCache&quot;) 
                .firstAccessFailObject(&quot;empty&quot;)
                .build();
        static { //想初始化缓存
                RELOADABLE_CACHE.get();
                }
        public static String getCache() {
                return RELOADABLE_CACHE.get();
            }
}
</code></pre>
<h2 id="问题根源">问题根源</h2>
<pre><code class="language-shell">http-nio-8080-exec-1&quot;#73 daemon prio=5 os_prio=31=296.82stid=0x00007fcb0077e000 nid=0xc903 waiting on ditionon
[0x000070000e6ea000]
    java.lang.Thread.State:WAITING (parking)
        at jdk.internal.misc.Unsafe.park(java.base@11.0.18/Native Method) 
        - parking to wait for&lt;0x0000000706500500&gt;(a com.google.common.util.concurrent.SettableFuture)
        at java.util.concurrent.Locks.LockSupport.park((java.base@11.0.18/LockSupport.java:194)
        at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:539)
        at com.github.phantomthief.localcache.impl.ZkNotifyReloadCache.init(ZkNotifyReloadcache.iava:156)
        at com.github.phantomthief.localcache.impl.ZkNotifyReloadCache.get(ZkNotifyReloadcache.iava:107)
        - locked &lt;0x0000000706500500&gt; （a  com.github.phantomthief.localcache.impl.ZkNotifyReloadCache）
        at com.kuaishou.xxxx.Utils.&lt;client&gt;(Utils.java.29)
</code></pre>
<p>乍一看并不知道什么导致了死锁阻塞，首先我们看下 jstack，发现请求过来的线程等待资源被挂起 了，下述代码是 ReloadableCache 中 init 操作的主要流程，大概意思是新起了一个线程用来进行 zk subscribe 等操作<br>
<img src="https://pittttt.github.io/post-images/1753618408312.png" alt="" loading="lazy"><br>
是不是新线程的 postCacheInit 方法没有完成呢，看下新线程的的执行情况，线程虽然是 RUNNING 状态，但是卡在了一个奇怪的地方，Utils 类的一个 lambda 表达式(com.kuaishou.keyconfig.util.Utils$$Lambda$1022)<br>
<img src="https://pittttt.github.io/post-images/1753618427987.png" alt="" loading="lazy"><br>
跟着线程堆栈找一下，发现卡在执行 scheduleRunDuration 这个 Supplier 变量的 get，而这个变量， 是在 Builder 中通过 enableAutoReload 方法进行初始化的，所以这个 lambda 表达式就是 Utils 类 中的初始化方法() -&gt; Duration.ofSeconds(Kconf.get())<br>
<img src="https://pittttt.github.io/post-images/1753618455475.png" alt="" loading="lazy"><br>
<img src="https://pittttt.github.io/post-images/1753618460425.png" alt="" loading="lazy"><br>
接下来我们用 javap 反编译下 Utils 类的代码看看 Lambda 做了什么<br>
<img src="https://pittttt.github.io/post-images/1753618487380.png" alt="" loading="lazy"><br>
首先可以看到 lambda 表达式会生成一个私有的静态函数，接下来我们看静态代码块中具体干了什么<br>
<img src="https://pittttt.github.io/post-images/1753618600214.png" alt="" loading="lazy"><br>
使用 javap -v 对文件进行反编译，可以看到在 static 代码块中执行了一条 invokedynamic 指令， 这条指令对应了代码中的 lambda 表达式，通过常量池中的标识操作数对应到 BootstrapMethods 属性表，所以这条指令最终走到了 java/lang/invoke/LambdaMetafactory.metafactory 这个方法，这个方法返回一个调用点对象 CallSite，它包含了一个方法句柄，会指向最终绑定到这个调用点上的方法<br>
<img src="https://pittttt.github.io/post-images/1753618828179.png" alt="" loading="lazy"><br>
metafactory 这个方法包含方法类型以及指向 lambda 表达式所代表的静态私有方法的方法句柄，最终通过 InnerClassLambdaMetafactory 创建内部匿名类，并通过 asm 动态生成字 节码，最后通过 unsafe 类的 defineAnonymousClass 方法将字节码转换为 class 文件，至 此，完成了一行 lambda 表达式，从字节码到静态匿名方法的转换<br>
<img src="https://pittttt.github.io/post-images/1753618663476.png" alt="" loading="lazy"><br>
<img src="https://pittttt.github.io/post-images/1753618212777.png" alt="" loading="lazy"><br>
<img src="https://pittttt.github.io/post-images/1753618252964.png" alt="" loading="lazy"><br>
整个调用流程大致如下:<br>
<img src="https://pittttt.github.io/post-images/1753618223244.png" alt="" loading="lazy"><br>
问题到这里，基本已经清晰了，类的初始化过程在整个生命周期中只会执行一次，第一个触发类初 始化的线程会获取该类的同步锁，在这个过程中，lambda 表达式又一次触发了同一个类的初始化， 造成了死锁</p>
<h2 id="参考">参考:</h2>
<p><a href="http://ifeve.com/jvm%e4%b9%8b%e5%8a%a8%e6%80%81%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8%ef%bc%9ainvokedynamic/">JVM 之动态方法调用:invokedynamic</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql中UNION查询的常见问题]]></title>
        <id>https://pittttt.github.io/post/mysql-zhong-union-cha-xun-de-chang-jian-wen-ti/</id>
        <link href="https://pittttt.github.io/post/mysql-zhong-union-cha-xun-de-chang-jian-wen-ti/">
        </link>
        <updated>2021-04-06T08:35:53.000Z</updated>
        <content type="html"><![CDATA[<p><strong>实习过程中用到了UNION查询，遇到不少问题，记录一下</strong><br>
这条sql语句的大体逻辑是这样的：需要从多张表中查询两种不同类型的数据，用UNION合并后，用动态sql语句来筛选，最后将所有数据排序</p>
<h4 id="union查询中的字段顺序">UNION查询中的字段顺序</h4>
<p>首先，两条select语句合并后再用where来筛选数据的方式有两种，为了方便已经将字段简化，下面为一种，也可以在两条select语句中先where筛选，之后使用UNION合并</p>
<pre><code class="language-sql">&lt;select id=&quot;queryList&quot; resultType=&quot;**VO&quot; parameterType=&quot;**VO&quot;&gt;
SELECT * FROM (
    SELECT
    t.tenant_code,o.object_subject,t.kr_code,t.object_code,
    IF(date_format(NOW(),'%Y-%m-%d') &lt;![CDATA[&gt;]]&gt; t.end_date, TRUE, FALSE) AS overdue
    FROM
    task t,
    objective o
    WHERE
    t.yn=1
    AND t.object_code = o.object_code

    UNION ALL
    SELECT
    t.tenant_code,o.object_subject,null,null,
    IF(date_format(NOW(),'%Y-%m-%d') &lt;![CDATA[&gt;]]&gt; t.end_date, TRUE, FALSE) AS overdue
    FROM
    task t
    WHERE
    t.type='normal'
    ) AS A
    WHERE
    A.overdue = 0
    &lt;if test=&quot;taskType != null&quot;&gt;
      AND A.task_type = #{taskType}
    &lt;/if&gt;
    ORDER BY sort ASC,id ASC
&lt;/select&gt;
</code></pre>
<p>上面的sql语句中有几点需要注意的：</p>
<ol>
<li><mark>被<![CDATA[]]]]><![CDATA[>这个标记所包含的内容将表示为纯文本</mark>，比如<![CDATA[>]]]]><![CDATA[>表示文本内容“&gt;”，因为sql语句是在xml文件中写的，在xml中，&quot;&lt;&quot;、&quot;&gt;&quot;、&quot;&amp;&quot;等字符是不能直接存入的</li>
<li><mark>第二条select语句中查询字段有两个null</mark>，因为union要求两个select语句的结果中的列必须是<mark>完全同名且同顺序的</mark>，但是如果列数量不同怎么办，可以用null来替代，不然sql会报错<code>The used SELECT statements have a different number of columns</code></li>
<li>在使用union查询后排序，需要指定临时表名，即上面代码中的<code>SELECT * FROM (***) AS A</code>，不然报错<code>Every derived table must have its own alias</code></li>
</ol>
<h4 id="union和union-all的区别">UNION和UNION ALL的区别</h4>
<p>UNION 操作会对结果去重且排序，而UNION ALL会直接返回合并结果，不做处理，所以UNION ALL的速度会更快，根据需求进行选择</p>
<p><strong>P.S.</strong>  实体类entity要根据使用场景不同来命名，Bo(business object)代表业务对象，Vo(value object)为值对象，通常同于和视图层进行交互，即后台和前端之间的传递对象，Po(persistant object)代表持久层对象的意思，对应数据库中表的字段</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决Github Pages不被百度收录的问题]]></title>
        <id>https://pittttt.github.io/post/github-pages-bu-bei-bai-du-shou-lu-de-wen-ti/</id>
        <link href="https://pittttt.github.io/post/github-pages-bu-bei-bai-du-shou-lu-de-wen-ti/">
        </link>
        <updated>2020-05-17T13:42:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>利用Github Pages搭建个人博客非常的方便，但是由于某些原因，Github Pages搭建的网站并不会被百度爬虫收录<br>
<img src="https://pittttt.github.io/post-images/1589766148383.PNG" alt="" loading="lazy"><br>
大多数解决方法为采用双仓库，将github上的仓库同步到coding pages上，之后利用<a href="https://www.dnspod.cn">dnspod</a>进行域名解析，将百度线路单独解析到coding pages，其他线路默认访问github，这里提供一种利用netlify托管平台来使百度爬虫收录的方法</p>
<h2 id="将github-pages项目托管至netlify网站">将Github Pages项目托管至netlify网站</h2>
<p>首先点击<strong>New site from Git</strong><br>
<img src="https://pittttt.github.io/post-images/1589767867405.PNG" alt="" loading="lazy"><br>
这里提供3个导入方式，选择GitHub<br>
<img src="https://pittttt.github.io/post-images/1589767943922.PNG" alt="" loading="lazy"><br>
选择你的Github Pages仓库<br>
<img src="https://pittttt.github.io/post-images/1589768022919.PNG" alt="" loading="lazy"><br>
这一步可以设置部署仓库的分支，编译命令和部署目录，如果是是编译后的静态文件，直接点击<strong>Deply site</strong>即可<br>
<img src="https://pittttt.github.io/post-images/1589769263504.PNG" alt="" loading="lazy"><br>
之后netlify会进行自动部署，等待几分钟后会生成一个随机网址，此时你就可以通过这个网站访问你的Github Pages上部署的博客了，你可以点击<strong>Domain settings</strong>进行域名设置，如修改为https://pitt.netlify.app<br>
<img src="https://pittttt.github.io/post-images/1589769768645.PNG" alt="" loading="lazy"><br>
也可以绑定你自己的域名，先在你的域名管理系统里新建解析，将域名CNAME指向到你的netlify二级域名，点击<strong>Add custom domain</strong>输入你的自定义域名即可<br>
<img src="https://pittttt.github.io/post-images/1589769638848.PNG" alt="" loading="lazy"><br>
最后可以为你的自定义域名开启HTTPS认证，域名验证通过会自动申请证书<br>
至此，部署过程就结束了，之后每次你更新Github Pages，都会自动同步到netlify<br>
<img src="https://pittttt.github.io/post-images/1589770050721.PNG" alt="" loading="lazy"></p>
<h2 id="验证是否会被百度爬虫收录">验证是否会被百度爬虫收录</h2>
<p><img src="https://pittttt.github.io/post-images/1589770553279.PNG" alt="" loading="lazy"><br>
可以看到百度爬虫是可以抓取到的，之后我又进行了网站测速，结果如下：<br>
<img src="https://pittttt.github.io/post-images/1589770609803.PNG" alt="" loading="lazy"><br>
由于是在网络使用高峰期进行测试的，网站的相应都比较慢，但是看到Github Pages的响应还是要比netlify快一倍，netlify是自动进行CDN加速的，可能是我没有配置独立域名的原因😅<br>
<strong>总结以上，如果觉得Github Pages访问过慢，可以将网站同时托管在Coding Pages上，将国内流量解析至Coding上，netlify可以暂时解决不被百度收录的问题</strong></p>
<p>P.S. 推荐一个图床：<a href="https://sm.ms">sm图床</a>个人觉得很好用🤠</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对Map的key和value分别进行排序]]></title>
        <id>https://pittttt.github.io/post/dui-map-de-key-he-value-fen-bie-jin-xing-pai-xu/</id>
        <link href="https://pittttt.github.io/post/dui-map-de-key-he-value-fen-bie-jin-xing-pai-xu/">
        </link>
        <updated>2020-05-13T15:02:05.000Z</updated>
        <content type="html"><![CDATA[<p><strong>今天写算法题的时候遇到了map的排序，记录一下</strong></p>
<p><strong>1.对map的key进行排序</strong><br>
最简单的就是利用TreeMap，TreeMap默认为升序排序，如果需要降序，调用descendingMap()方法即可，代码如下：</p>
<pre><code class="language-java">public static void main(String[] args) {
		// 默认按照key值正序排列
		Map&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;();
		// 按照key值倒序排列
		// Map&lt;Object, Object&gt; treeMap = new TreeMap&lt;&gt;().descendingMap();
		treeMap.put(&quot;b&quot;, 3);
		treeMap.put(&quot;c&quot;, 4);
		treeMap.put(&quot;a&quot;, 7);
		treeMap.put(&quot;d&quot;, 1);
		for (Map.Entry&lt;Object, Object&gt; entry : treeMap.entrySet()) {
			System.out.println(&quot;Key=&quot; + entry.getKey() + &quot;, Value=&quot; + entry.getValue());
		}
	}
	
	//输出为
	Key=a, Value=7
	Key=b, Value=3
	Key=c, Value=4
	Key=d, Value=1
</code></pre>
<p><strong>2.对map的value进行排序</strong><br>
将map的entry转化为list，通过sort()方法进行排序后输出，此方法同样适用于TreeMap，代码如下:</p>
<pre><code class="language-java">public static void main(String[] args) {
		Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();
		hashMap.put(&quot;b&quot;, 3);
		hashMap.put(&quot;c&quot;, 4);
		hashMap.put(&quot;a&quot;, 7);
		hashMap.put(&quot;d&quot;, 1);
		// 转换成list
		List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;&gt;(hashMap.entrySet());
		Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() {
			// 升序排序
			@Override
			public int compare(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2) {
				return o1.getValue().compareTo(o2.getValue());
			}
		});
		// 初始排列顺序
		System.out.println(&quot;初始顺序为&quot;);
		for (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) {
			System.out.println(&quot;Key=&quot; + entry.getKey() + &quot;, Value=&quot; + entry.getValue());
		}
		System.out.println(&quot;---------&quot;);
		// 按照value排序后输出
		System.out.println(&quot;value排序后顺序为&quot;);
		for (Map.Entry&lt;String, Integer&gt; entry : list) {
			System.out.println(&quot;Key=&quot; + entry.getKey() + &quot;, Value=&quot; + entry.getValue());
		}
	}
	
	//输出为
	初始顺序为
	Key=a, Value=7
	Key=b, Value=3
	Key=c, Value=4
	Key=d, Value=1
	---------
	value排序后顺序为
	Key=d, Value=1
	Key=b, Value=3
	Key=c, Value=4
	Key=a, Value=7
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World]]></title>
        <id>https://pittttt.github.io/post/hello-world/</id>
        <link href="https://pittttt.github.io/post/hello-world/">
        </link>
        <updated>2020-05-13T13:03:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一篇">第一篇</h1>
<p>在阿里云上部署了自己第一个个人博客<a href="http://39.99.146.207:8090">http://39.99.146.207:8090</a>，没有绑定域名，就是这么丑:）索性再建一个静态博客🤠<br>
今后可以陆续把自己<a href="https://blog.csdn.net/Pitt_96">CSDN</a>上的文章搬运过来🤠</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[招商银行2020FinTech精英训练营笔试题目题解]]></title>
        <id>https://pittttt.github.io/post/zhao-shang-yin-xing-2020fintech-jing-ying-xun-lian-ying-bi-shi-ti-mu-ti-jie/</id>
        <link href="https://pittttt.github.io/post/zhao-shang-yin-xing-2020fintech-jing-ying-xun-lian-ying-bi-shi-ti-mu-ti-jie/">
        </link>
        <updated>2020-05-10T15:25:40.000Z</updated>
        <content type="html"><![CDATA[<p>笔试题目为招商银行2020FinTech精英训练营笔试题目，都没有AC，记录一下，还是要多做题多进行总结</p>
<p><strong>题目一描述:</strong>  小招在玩一款游戏：在一个N层高的金字塔上，以金字塔顶为第一层，第i层有i个落点，每个落点有若干枚金币，在落点可以跳向左斜向下或向右斜向下的落点。若知道金字塔的层数N及每层的金币数量分布，请计算小招在本次游戏中可以获得的最多金币数量。<br>
<strong>测试输入：</strong> 第一行输入为层数<br>
5<br>
8<br>
3 8<br>
8 1 0<br>
4 7 5 4<br>
3 5 2 6 5<br>
<strong>测试输出：31</strong><br>
此题为典型的DP题目，一开始我使用递归遍历所有和，结果超时了，下面为标准解法：</p>
<pre><code class="language-java">public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int[][] a = new int[1024][1024];//可以通过题目限制条件，如N&lt;=1024来设定数组大小
		//将金字塔存入二维数组
		for (int i = 1; i &lt; n + 1; i++) {
			for (int j = 0; j &lt; i; j++) {
				a[i][j] = in.nextInt();
			}
		}
		//从低向上计算，通过下面一层计算当前层的最大和
		for (int i = n - 1; i &gt;= 1; i--) {
			for (int j = 0; j &lt; i; j++) {
				a[i][j] += Math.max(a[i + 1][j], a[i + 1][j + 1]);
			}
		}
		System.out.println(a[1][0]);
	}
</code></pre>
<p><mark>动态规划的精髓在于由底向上的进行计算来确保此时所得到的一定是最大值，从全局所有情况开始考虑，逐渐收束到最大值，而不是由上向下的做选择，因为选择后面的情况无法预料，每次需要递归到最后，导致递归的时间复杂度过大，可以理解为一种逆向计算过程</mark></p>
<p><strong>题目二描述:</strong> 在一场集体婚礼上，有n对新人需要坐在连续排列的 2n个座位上合影，同一对新人彼此挨着。由于进场时各对新人并未按序入座，请计算最少交换座位的次数，以便使每对新人均可并肩坐在一起。一次交换可选择任意两人，让他们互换座位。<br>
全部新人的序号可用 0 到 2n-1 的整数表示，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。<br>
row[i]指最初坐在第 i 个座位上的新人编号，i是从0到（2n-1）的一个升序全排列，row不存在重复值。<br>
<strong>测试输入：</strong> 第一行为n，即共有多少对新人(2≤n≤100000 )，第二行为row，即2n个座位上的初始新人编号。<br>
2<br>
0 2 1 3<br>
<strong>测试输出：1</strong></p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){
            int n = sc.nextInt();
            int[] arr = new int[2*n];
            for(int i=0; i&lt;2*n; i++){
                arr[i] = sc.nextInt();
            }
            int count = helper(arr);
            System.out.println(count);
        }
    }
    public static int helper(int[] row) {
        int count = 0;
        for (int i = 0; i &lt; row.length; i += 2) {
            int x = row[i];
            if (row[i+1] == (x ^ 1)) continue;
            count++;
            for (int j = i+1; j &lt; row.length; ++j) {
                if (row[j] == (x^1)) {
                    row[j] = row[i+1];
                    row[i+1] = x^1;
                    break;
                }
            }
        }
        return count;
    }
}
</code></pre>
<p>新人两两成对，所以外部遍历左边第一位的编号，如果当前两位符合要求，则继续遍历，不符合则遍历寻找从此开始符合的那一位，进行交换，<mark>此题如果使用和1异或的性质则会节省很多代码</mark></p>
<blockquote>
<p>x^1：一个数x和1异或，如果x为偶数，异或结果为x+1,如果x为奇数，结果为x-1</p>
</blockquote>
<p><strong>题目三描述:</strong> 小招正在玩一款修塔游戏：系统中有n座高塔，每座高塔由若干个高度相同的方块堆砌而成。修塔游戏的规则为：<br>
（1）每次从最高塔的塔尖拿走一个方块<br>
（2）每次在最低塔的塔尖堆砌一个方块<br>
小招每次只能完成上述两个动作中的一个动作。游戏的目标是使n座高塔中至少有k座高塔的高度相同，请问小招最少需要多少次才能完成游戏。<br>
<strong>测试输入：</strong> 输入共有2行，第一行为n和k(1≤k≤n≤200000 )，第二行为n座塔的高度组成的数组 a1, a2, ...an(1≤aj≤10000)。<br>
6 5<br>
1 2 2 4 2 3<br>
<strong>测试输出：3</strong></p>
<p><mark>主要解题思路放在代码注释中了</mark></p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = in.nextInt();
        }
        System.out.println(helper(arr, n, k));
    }
 
    public static int helper(int[] arr, int n, int k) {
        int[] count = new int[10001];
        int minT = Integer.MAX_VALUE;
        int maxT = 0;
        //将每个高度出现的次数存入数组，遍历后找出最高和最低
        for (int a : arr) {
            count[a]++;
            minT = Math.min(a, minT);
            maxT = Math.max(a, maxT);
        }
 
        int ans = Integer.MAX_VALUE;
        //从最小高度开始找
        //整体思路为遍历每个高度，然后分别求其他塔变成当前高度所需次数，在所有结果中求最小值，过程分别为降低高度和增加高度，单独求解次数
        for (int i = minT; i &lt;= maxT; i++) {
        //如果此时高度数量满足要求，则不需要移动
            if (count[i] &gt;= k)
                return 0;
 
 			//从最低塔尖堆砌
            int inc = 0;
            int incCnt = 0;
             /*
            最低和最高的思路是正好相反的
            这里的思路是这样的：
			由于每次只能堆砌最低塔尖，则必须将除了此时i高度的塔都堆砌到同一高度，即等于i-1的那个高度，最后加上缺少的数量则为结果，每次加完更新最小值为结果
            */
            for (int j = minT; j &lt; i; j++) {
                if (count[j] != 0) {
                    incCnt += count[j];
                    inc += (i - 1 - j) * count[j];
                }
            }
            if (incCnt &gt;= k - count[i]) {
                inc += k - count[i];
                ans = Math.min(ans, inc);
            }
 
 			//从最高塔尖拿走
            int dec = 0;
            int decCnt = 0;
            /*
            这里的思路是这样的：
			由于每次只能拿最高塔尖，则将除了此时i高度的塔都拿到同一高度，即等于i+1的那个高度，最后加上缺少的数量则为结果，每次加完更新最小值为结果
            */
            for (int j = i + 1; j &lt;= maxT; j++) {
                if (count[j] != 0) {
                    decCnt += count[j];
                    dec += (j - i - 1) * count[j];
                }
            }
            if (decCnt &gt;= k - count[i]) {
                dec += k - count[i];
                ans = Math.min(ans, dec);
            }
 
        }
        return ans;
    }
}
</code></pre>
<p>第三道题本身并不是运用了很复杂的算法，但是发现自己的数学抽象能力有待提高，要将题目所给的条件转化为数字之间的逻辑关系，这才是这类题目的切入点，首先要理解题目。<br>
<strong>如这道题需要理解到，要想求出正确的操作次数，要知道如果当前高度为i，其他塔高必须要满足i+1/i-1才可以继续操作移动塔高满足要求，问题到这里就迎刃而解了</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode不同路径的两种BP解法]]></title>
        <id>https://pittttt.github.io/post/leetcode-bu-tong-lu-jing-de-liang-chong-bp-jie-fa/</id>
        <link href="https://pittttt.github.io/post/leetcode-bu-tong-lu-jing-de-liang-chong-bp-jie-fa/">
        </link>
        <updated>2020-04-15T07:49:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>题目如下：</strong><br>
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>
输入：<br>
[<br>
[0,0,0],<br>
[0,1,0],<br>
[0,0,0]<br>
]<br>
输出: 2</p>
<p>来源：<a href="https://leetcode-cn.com/problems/unique-paths-ii">leetcode63.不同路径II</a><br>
<img src="https://img-blog.csdnimg.cn/20200415145234122.png" alt="在这里插入图片描述" loading="lazy"><br>
这道题采用经典的BP解法，但是在实现BP时，我一开始采用了和<a href="https://leetcode-cn.com/problems/unique-paths/">leetcode62.不同路径</a>同样的递归实现，62可以通过全部测试用例，此题代码如下：</p>
<pre><code class="language-java">class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        long[][] cache=new long[obstacleGrid.length][obstacleGrid[0].length];
        return (int)dp(obstacleGrid,0,0,cache,0);
    }
    
    public long dp(int[][] obstacleGrid,int x,int y,long[][] cache,int n){
    	//如果能走到右下角
        if(n==obstacleGrid.length+obstacleGrid[0].length-2&amp;&amp;x==obstacleGrid.length-1&amp;&amp;y==obstacleGrid[0].length-1&amp;&amp;obstacleGrid[x][y]==0){
            return 1;
        //越界或者碰到障碍
        }else if(x&gt;=obstacleGrid.length||y&gt;=obstacleGrid[0].length||obstacleGrid[x][y]==1){
            return 0;
        }
        if(cache[x][y]!=0) return cache[x][y];
        cache[x][y]=dp(obstacleGrid,x+1,y,cache,n+1)+dp(obstacleGrid,x,y+1,cache,n+1);
        return cache[x][y];
    }
}
</code></pre>
<p>虽然使用了缓存数组来储存每步结果，但是还是超时了<img src="https://img-blog.csdnimg.cn/20200415150052573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
使用了BP Table数组最后通过</p>
<pre><code class="language-java">class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid==null||obstacleGrid.length&lt;0){
            return 0;
        }
        int rows=obstacleGrid.length;
        int cols=obstacleGrid[0].length;
        //dp数组的含义为可以到达这个坐标，则路径数为1，下一个坐标等于前两个坐标之和
        int[][] dp=new int[rows][cols];
        //进行初始化，只有向右和向下两个方向，则障碍物后面的都不能可以走
        for(int i=0;i&lt;cols;i++){
            if(obstacleGrid[0][i]==1){
                break;
            }else{
                dp[0][i]=1;
            }
        }
        for(int i=0;i&lt;rows;i++){
            if(obstacleGrid[i][0]==1){
                break;
            }else{
                dp[i][0]=1;
            }
        }
        //从1开始，防止下标越界
        for(int i=1;i&lt;rows;i++){
            for(int j=1;j&lt;cols;j++){
                if(obstacleGrid[i][j]==1){
                    dp[i][j]=0;
                }else{
                    dp[i][j]=dp[i-1][j]+dp[i][j-1];
                }
            }
        }
        return dp[rows-1][cols-1];
    }
}
</code></pre>
<p>虽然都是BP算法，原因可能是因为递归深度太大，导致超时，BP Table的适用范围更广</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot项目调优及垃圾回收器的比较]]></title>
        <id>https://pittttt.github.io/post/springboot-xiang-mu-diao-you-ji-la-ji-hui-shou-qi-de-bi-jiao/</id>
        <link href="https://pittttt.github.io/post/springboot-xiang-mu-diao-you-ji-la-ji-hui-shou-qi-de-bi-jiao/">
        </link>
        <updated>2020-04-02T15:47:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-springboot项目在外部tomcat启动时加载两次">一、SpringBoot项目在外部Tomcat启动时加载两次</h2>
<p>如下所示，spring标志出现两次(截取部分代码)</p>
<pre><code> .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.5.7.RELEASE)

2020-04-02 16:57:29.505  INFO 19964 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : Starting MainApplication on LAPTOP-1U9EARRO with PID 19964 (D:\apache-tomcat-8.5.42\apache-tomcat-8.5.42\webapps\kill-0.0.1-SNAPSHOT\WEB-INF\classes started by pitt in C:\Users\pitt\AppData\Local\MyEclipse 2017 CI)
2020-04-02 16:57:29.508 DEBUG 19964 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : Running with Spring Boot v1.5.7.RELEASE, Spring v4.3.11.RELEASE
2020-04-02 16:57:29.509  INFO 19964 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : No active profile set, falling back to default profiles: default
2020-04-02 16:57:29.539  INFO 19964 --- [ost-startStop-1] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@1e20bc0d: startup date [Thu Apr 02 16:57:29 GMT+08:00 2020]; root of context hierarchy
2020-04-02 16:57:30.097  INFO 19964 --- [ost-startStop-1] o.s.b.f.xml.XmlBeanDefinitionReader      : Loading XML bean definitions from class path resource [spring/spring-jdbc.xml]
2020-04-02 16:57:30.141  WARN 19964 --- [ost-startStop-1] o.m.s.mapper.ClassPathMapperScanner      : No MyBatis mapper was found in '[com.pitt.kill.model.mapper]' package. Please check your configuration.
2020-04-02 16:57:30.258  WARN 19964 --- [ost-startStop-1] o.m.s.mapper.ClassPathMapperScanner      : No MyBatis mapper was found in '[com.pitt.kill.server]' package. Please check your configuration.
2020-04-02 16:57:30.307  INFO 19964 --- [ost-startStop-1] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.5.7.RELEASE)

2020-04-02 16:57:37.069  INFO 19964 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : Starting MainApplication on LAPTOP-1U9EARRO with PID 19964 (D:\apache-tomcat-8.5.42\apache-tomcat-8.5.42\webapps\server\WEB-INF\classes started by pitt in C:\Users\pitt\AppData\Local\MyEclipse 2017 CI)
2020-04-02 16:57:37.072 DEBUG 19964 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : Running with Spring Boot v1.5.7.RELEASE, Spring v4.3.11.RELEASE
2020-04-02 16:57:37.072  INFO 19964 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : No active profile set, falling back to default profiles: default
2020-04-02 16:57:37.102  INFO 19964 --- [ost-startStop-1] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@1565ae71: startup date [Thu Apr 02 16:57:37 GMT+08:00 2020]; root of context hierarchy
2020-04-02 16:57:37.675  INFO 19964 --- [ost-startStop-1] o.s.b.f.xml.XmlBeanDefinitionReader      : Loading XML bean definitions from class path resource [spring/spring-jdbc.xml]
2020-04-02 16:57:37.863  INFO 19964 --- [ost-startStop-1] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!
2020-04-02 16:57:38.422  INFO 19964 --- [ost-startStop-1] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.amqp.rabbit.annotation.RabbitBootstrapConfiguration' of type [org.springframework.amqp.rabbit.annotation.RabbitBootstrapConfiguration$$EnhancerBySpringCGLIB$$6cdea02f] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-04-02 16:57:38.456  INFO 19964 --- [ost-startStop-1] trationDelegate$BeanPostProcessorChecker : Bean 'shiroConfig' of type [com.pitt.kill.server.config.ShiroConfig$$EnhancerBySpringCGLIB$$4392bed0] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
</code></pre>
<p>加载时间30s</p>
<pre><code>2020-04-02 16:57:42.825  INFO 19964 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : Started MainApplication in 6.091 seconds (JVM running for 30.348)
2020-04-02 16:57:42.946  INFO 19964 --- [           main] org.apache.catalina.startup.Catalina     : Server startup in 29361 ms
</code></pre>
<p>原因：打开配置文件server.xml，Tomcat在启动web项目时，会首先在Host标签中找webapps下的项目，进行加载后，又会在Context 标签中再次加载，导致加载两次<br>
<mark>解决:</mark> 将appBase=&quot;webapps&quot;替换为appBase = &quot; &quot;</p>
<pre><code class="language-bash">&lt;Host appBase=&quot;webapps&quot; autoDeploy=&quot;true&quot; name=&quot;localhost&quot; unpackWARs=&quot;true&quot;&gt;
</code></pre>
<pre><code class="language-bash">&lt;Context docBase=&quot;D:\apache-tomcat-8.5.42\apache-tomcat-8.5.42\webapps\server&quot; path=&quot;&quot; reloadable=&quot;true&quot; source=&quot;org.eclipse.jst.jee.server:server&quot;/&gt;
</code></pre>
<p>加载一次时间为12s</p>
<pre><code>2020-04-02 17:03:12.759  INFO 952 --- [ost-startStop-1] com.pitt.kill.server.MainApplication     : Started MainApplication in 7.478 seconds (JVM running for 12.532)
2020-04-02 17:03:13.100  INFO 952 --- [           main] org.apache.catalina.startup.Catalina     : Server startup in 11772 ms
</code></pre>
<h2 id="二-禁用字节码验证过程">二、禁用字节码验证过程</h2>
<p>对类的加载时间进行优化，首先查看类的加载时间</p>
<pre><code class="language-bash">C:\Program Files\Java\jdk1.8.0_211\bin&gt;jps
16612 QuorumPeerMain
9172 Main
19416 MyEclipse
952 Bootstrap
19580 Jps

C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstat -class 952
Loaded  Bytes  Unloaded  Bytes     Time
 10533 20062.0        0     0.0       7.83
</code></pre>
<p>我们默认通过MyEclipse编译的代码是可靠的，不需要在加载的时候进行字节码验证，使用-Xverify:none参数将字节码验证过程禁用掉，来提升类的加载速度</p>
<pre><code class="language-bash">C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstat -class 12308
Loaded  Bytes  Unloaded  Bytes     Time
  9822 18874.2        0     0.0       6.70
</code></pre>
<p>提升效果一般，只减少了1s<br>
此外由于HotSpot采用了JIT编译器可以提前加载热代码，1.8版本JVM的代码编译速度已经比较优秀，此处不做优化</p>
<h2 id="三-调整内存设置控制垃圾收集频率">三、调整内存设置控制垃圾收集频率</h2>
<p>Java8默认的GC回收器为Parallel Scavenge + Parallel Old<br>
<img src="https://img-blog.csdnimg.cn/202004030002075.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
用Jmeter发送请求作为辅助测试<br>
可以看到，测试时间内，发起了103次Minor GC，耗时不到1s，其实时间停顿并不多，但是5次Full GC占用了很大部分的GC时间，主要针对这部分时间进行优化。通过-Xloggc:gc.log -XX:+PrintGCTimeStamps -XX:+PrintGCDetails参数打印GC日志，将Full GC挑出如下：</p>
<pre><code>7.934: [Full GC (Metadata GC Threshold) [PSYoungGen: 926K-&gt;0K(647680K)] [ParOldGen: 54198K-&gt;15711K(65024K)] 55125K-&gt;15711K(712704K), [Metaspace: 20674K-&gt;20674K(1069056K)], 0.0303162 secs] [Times: user=0.03 sys=0.00, real=0.03 secs] 
10.430: [Full GC (Metadata GC Threshold) [PSYoungGen: 3883K-&gt;0K(646656K)] [ParOldGen: 20986K-&gt;17184K(80896K)] 24870K-&gt;17184K(727552K), [Metaspace: 34377K-&gt;34377K(1081344K)], 0.0413074 secs] [Times: user=0.28 sys=0.00, real=0.04 secs] 
379.971: [Full GC (Metadata GC Threshold) [PSYoungGen: 2528K-&gt;0K(93696K)] [ParOldGen: 65885K-&gt;58730K(132096K)] 68413K-&gt;58730K(225792K), [Metaspace: 57642K-&gt;57535K(1101824K)], 0.3908541 secs] [Times: user=0.97 sys=0.00, real=0.39 secs] 
390.977: [Full GC (Ergonomics) [PSYoungGen: 8688K-&gt;0K(230400K)] [ParOldGen: 129221K-&gt;120704K(226304K)] 137909K-&gt;120704K(456704K), [Metaspace: 62151K-&gt;62115K(1105920K)], 0.1319683 secs] [Times: user=0.50 sys=0.02, real=0.13 secs] 
553.770: [Full GC (Ergonomics) [PSYoungGen: 47104K-&gt;0K(513536K)] [ParOldGen: 228052K-&gt;120789K(249344K)] 275156K-&gt;120789K(762880K), [Metaspace: 62330K-&gt;62330K(1105920K)], 0.1344527 secs] [Times: user=0.27 sys=0.02, real=0.13 secs] 
</code></pre>
<p>每一次Full GC都伴随着老年代的扩容，日志还显示有时候内存回收状况不理想，获取可用的内存主要通过空间的扩容。<br>
查看运行期间的CPU使用情况，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200403000356479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
垃圾回收的CPU使用率曲线几乎看不到，CPU资源还有可利用的余地，为此想到更换原有的垃圾回收器来进行GC优化</p>
<p><strong>CMS:</strong><br>
相比于默认的Parallel GC明显改善了Full GC所消耗的时间，Stop The World时间减少，但是Minor GC大量增加，尝试调整新生代的大小来减少Minor GC的产生，在使用-XX:NewRatio=1 -XX:SurvivorRatio=3<br>
-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=85参数进行调整后，Minor GC数量下降，但是相比而言还是很多<br>
<img src="https://img-blog.csdnimg.cn/20200402231900903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<strong>G1:</strong><br>
G1为最新的垃圾回收算法，将新生代和老年代同时进行标记和回收，采用标记-整理算法，不会产生内存碎片，在时间消耗上表现的最好，平均每次回收占用的时间最短，并且最好在内存比较大的机器上使用G1算法进行回收<br>
<img src="https://img-blog.csdnimg.cn/20200402233250733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<strong>G1的优势在于:</strong><br>
作为CMS的长期替代品<br>
1、G1是一个压缩收集器，提供足够强的压缩来完全避免狭小的内存分配<br>
2、依赖Regions概念，大大简化收集器逻辑，大部分情况下规避潜在的内存碎片问题<br>
3、比CMS的GC停顿时长更加可预测，并允许用户指定停顿时长</p>
<p><strong>总结:</strong><br>
以上三种回收器都为多线程垃圾回收器，但是对于不同的环境，应该具体问题具体分析，而不是采用一刀切的方法，解决问题的过程即为寻找最优解的过程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[查看java程序堆内存等命令和jvm可视化工具]]></title>
        <id>https://pittttt.github.io/post/cha-kan-java-cheng-xu-dui-nei-cun-deng-ming-ling-he-jvm-ke-shi-hua-gong-ju/</id>
        <link href="https://pittttt.github.io/post/cha-kan-java-cheng-xu-dui-nei-cun-deng-ming-ling-he-jvm-ke-shi-hua-gong-ju/">
        </link>
        <updated>2020-03-14T15:40:50.000Z</updated>
        <content type="html"><![CDATA[<p><strong>几个主要的命令：</strong><br>
jps:与unix上的ps类似，用来显示本地的java进程，可以查看本地运行着几个java程序，并显示他们的进程号。<br>
jstat:一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量。<br>
jmap:打印出某个java进程（使用pid）内存内的所有'对象'的情况（如：产生那些对象，及其数量）。<br>
jconsole:一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。</p>
<p><em>启动秒杀系统作为测试</em></p>
<p><strong>1、JPS命令</strong><br>
可以查到当前服务器启动的进程号为2128</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jps
2128 Bootstrap
8720 MyEclipse
23704 QuorumPeerMain
29288 Jps
</code></pre>
<p><strong>2、JSTAT命令</strong><br>
此命令可以用来查看加载class的数量级占用的空间</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstat -class 2128
Loaded  Bytes  Unloaded  Bytes     Time
 21627 40737.3        0     0.0      17.63
</code></pre>
<hr>
<p>此命令可以用来产看jvm编译的数量信息</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstat -compiler 2128
Compiled Failed Invalid   Time   FailedType FailedMethod
   10344      3       0    45.47          1 org/springframework/beans/GenericTypeAwarePropertyDescriptor &lt;init&gt;
</code></pre>
<hr>
<p>此命令可以用来查看GC的信息和GC的次数</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstat -gc 2128
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
512.0  1024.0 384.0   0.0   133120.0 74622.8   163840.0   71196.1   119792.0 117433.6 14896.0 14580.7    116    0.763   4      0.332    1.095
</code></pre>
<hr>
<p>此命令可以用来产看young，old和perm区的对象和使用大小</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstat -gccapacity 2128
 NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC
 43520.0 689152.0 235008.0  512.0  512.0 121856.0    87552.0  1379328.0   163840.0   163840.0      0.0 1155072.0 119792.0      0.0 1048576.0  14896.0    227     4
</code></pre>
<hr>
<p>此命令可以用来查看当前VM执行信息</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstat -printcompilation 2128
Compiled  Size  Type Method
   10468      2    1 java/nio/DirectByteBuffer isDirect
</code></pre>
<p><strong>3、jinfo 可以用来查看和更改java进程运行的参数</strong></p>
<p><strong>4、jmap命令可以用来查看堆中的活动对象及大小</strong></p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jmap -heap 2128
Attaching to process ID 2128, please wait...
Debugger attached successfully.
Client compiler detected.

using thread-local object allocation.
Mark Sweep Compact GC

Heap Configuration:
   MinHeapFreeRatio = 40
   MaxHeapFreeRatio = 70
   MaxHeapSize      = 268435456 (256.0MB)
   NewSize          = 1048576 (1.0MB)
   MaxNewSize       = 4294901760 (4095.9375MB)
   OldSize          = 4194304 (4.0MB)
   NewRatio         = 2
   SurvivorRatio    = 8
   PermSize         = 12582912 (12.0MB)
   MaxPermSize      = 67108864 (64.0MB)
   G1HeapRegionSize = 0 (0.0MB)

Heap Usage:
New Generation (Eden + 1 Survivor Space):
   capacity = 36700160 (35.0MB)
   used     = 4734920 (4.515571594238281MB)
   free     = 31965240 (30.48442840576172MB)
   12.901633126395089% used
Eden Space:
   capacity = 32636928 (31.125MB)
   used     = 4734920 (4.515571594238281MB)
   free     = 27902008 (26.60942840576172MB)
   14.50786054373745% used
From Space:
   capacity = 4063232 (3.875MB)
   used     = 0 (0.0MB)
   free     = 4063232 (3.875MB)
   0.0% used
To Space:
   capacity = 4063232 (3.875MB)
   used     = 0 (0.0MB)
   free     = 4063232 (3.875MB)
   0.0% used
tenured generation:
   capacity = 81498112 (77.72265625MB)
   used     = 30978160 (29.543075561523438MB)
   free     = 50519952 (48.17958068847656MB)
   38.0108928167563% used
Perm Generation:
   capacity = 39059456 (37.25MB)
   used     = 38951352 (37.14690399169922MB)
   free     = 108104 (0.10309600830078125MB)
   99.72323219248112% used

22804 interned Strings occupying 2668488 bytes.
</code></pre>
<p><strong>5、jconsole工具</strong><br>
输入jconsole后出现jconsole的界面<br>
<img src="https://img-blog.csdnimg.cn/20200314233011602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200314233047801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
其中内存分区如下说明，</p>
<p>Eden Space (heap)： 内存最初从这个线程池分配给大部分对象。<br>
Survivor Space (heap)：用于保存在eden space内存池中经过垃圾回收后没有被回收的对象。<br>
Tenured Generation (heap)：用于保持已经在 survivor space内存池中存在了一段时间的对象。<br>
Permanent Generation (non-heap): 保存虚拟机自己的静态(refective)数据，例如类（class）和方法（method）对象。Java虚拟机共享这些类数据。这个区域被分割为只读的和只写的，<br>
Code Cache (non-heap):HotSpot Java虚拟机包括一个用于编译和保存本地代码（native code）的内存，叫做“代码缓存区”（code cache）<br>
<strong>6、jstack命令</strong><br>
此命令用来查看进程下jvm的运行状态</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_211\bin&gt;jstack 2128
</code></pre>
<p><strong>7、工具</strong><br>
bin目录下提供了多种工具来监控jvm的运行运行状态，能通过图示很好的进行监控以便进行问题排查和优化</p>
<p>jvisualvm.exe<br>
<img src="https://img-blog.csdnimg.cn/20200314233745717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<hr>
<p>jmc.exe<br>
<img src="https://img-blog.csdnimg.cn/20200314233947488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BpdHRfOTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>参考：http://boendev.iteye.com/blog/882479</p>
</blockquote>
]]></content>
    </entry>
</feed>